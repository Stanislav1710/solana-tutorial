# Урок 10 — Seed: бинарный seed, импорт и восстановление ключей (без мнемоник/BIP-39)

---

## 1. Введение — что это за урок и почему важен

В этом уроке мы рассматриваем **seed** как бинарную основу для генерации приватного ключа в Solana. Здесь нет и не будет обсуждения мнемонических фраз (BIP‑39) — мы работаем исключительно с двоичными seed'ами и механизмами, которые нужны для корректной работы с `solders` и Solana.

Цели урока:
- объяснить, что такое seed в контексте Ed25519 и почему он обычно 32 байта;
- показать, как создавать, сохранять и безопасно загружать ключи (Keypair) из seed/байтов;
- предложить практику: создать один «репрезентативный» ключ, который мы будем использовать в следующих уроках курса и зафондить (airdrop), чтобы не дублировать действия.

---

## 2. Что такое seed (в бинарном виде)

- **Seed** — это последовательность случайных байт (в Solana обычно 32 байта), служащая входом для генерации приватного ключа Ed25519.
- Из seed через криптографические операции (SHA-512 и преобразования, описанные в Ed25519) получают приватный ключ и публичный ключ.
- Seed — это не человекочитаемая фраза, это **байты**. Важная мысль: seed — это приватный материал; его нужно хранить в зашифрованном виде.

Почему мы избегаем мнемоник здесь:
- мнемоники (BIP‑39) — это отдельный стандарт, который опосредованно превращает байты в слова; он добавляет уровень совместимости с кошельками, но в рамках этого курса мы хотим работать на бинарном уровне и понимать реальные байты, которые подставляет `solders`.

---

## 3. Генерация seed и Keypair (рекомендуемый базовый сценарий для курса)

Мы предлагаем участникам курса сгенерировать один Keypair сейчас и **использовать его в дальнейших уроках**. Это избавит от дублирования кода и упростит примеры (везде будет один и тот же адрес и возможность пополнить его через airdrop).

Рекомендация по хранению: сохраните **64 байта** (bytes(Keypair)) в зашифрованном файле `course_wallet.bin` в корне репозитория, добавив файл в `.gitignore`.

Используем код из [`examples/Python/L10-Create_course_keypair.py`](../examples/Python/L10-Create_course_keypair.py):
```python
from solders.keypair import Keypair

# 1) Создаём ключ для курса
course_kp = Keypair()
print("Course pubkey:", course_kp.pubkey())

# 2) Сохраняем сериализованные 64 байта
with open("course_wallet.bin", "wb") as f:
    f.write(bytes(course_kp))

print("Сохранено в course_wallet.bin (64 байта). Добавьте файл в .gitignore для безопасности.")
```

---

## 4. Загрузка Keypair из бинарного seed (64 байта)

При восстановлении важно подавать именно **64 байта** — сочетание secret (32) + public (32). Если подавать 32 байта, `Keypair.from_bytes` выбросит ошибку.

Используем код из [`examples/Python/L10-Load_course_keypair.py`](../examples/Python/L10-Load_course_keypair.py):
```python
from solders.keypair import Keypair

with open("course_wallet.bin", "rb") as f:
    raw = f.read()

kp = Keypair.from_bytes(raw)  # требует 64 байта
print("Загружен pubkey:", kp.pubkey())
```

---

## 5. Альтернативы: детерминированное получение Keypair из seed (32 байта)

Если вы хотите детерминированно получать Keypair из 32-байтового seed (например, для тестов), можно хранить 32-байтовый seed и формировать Keypair специальной функцией, которая ожидает на вход seed. Важно понимать: `Keypair.from_bytes` ожидает 64 байта — поэтому если у вас только seed (32), нужно сгенерировать публичную часть и собрать 64 байта вручную или использовать библиотеку, которая это делает.

Демонстрационный пример:
```python
# Пример: детерминированная генерация (псевдокод / концепт)
# В production используйте проверенные реализации (ed25519 library) для derive_from_seed

from solders.keypair import Keypair
import os

seed32 = os.urandom(32)
# Дальше используйте внешнюю библиотеку ed25519 для получения full private + public bytes
# затем конструируйте Keypair.from_bytes(private_plus_public)
```

> Замечание: этот пример даёт концепцию. Не пытайтесь вручную собирать байты без корректной криптографии — используйте готовые имплементации.

---

## 6. Рекомендации по безопасности хранения

1. **Файловая система:** храните `course_wallet.bin` в зашифрованном виде (gpg, age) и добавьте в `.gitignore`.
2. **Права доступа:** chmod 600 (только владелец) на Unix-системах.
3. **KMS/HSM:** для продакшна используйте KMS (AWS/GCP/Azure) или аппаратные модули.
4. **Логи:** никогда не логируйте `bytes(kp)` или приватные данные.

---

## 7. Как пополнить (airdrop) и где в курсе это описано

Мы будем использовать один и тот же адрес `course_kp.pubkey()` во многих примерах. Для удобства пополните его через Devnet, используя `solana-cli` или RPC.

Ссылка на урок с подробной инструкцией по airdrop и проверке баланса: **Урок 13 — Airdrop в devnet и проверка баланса через RPC**. (см. Lesson_13.md)

Пример быстрого airdrop через Python (devnet):

Используем код из [`examples/Python/L10-Airdrop_course_wallet.py`](../examples/Python/L10-Airdrop_course_wallet.py):
```python
from solana.rpc.api import Client
from solders.pubkey import Pubkey

client = Client("https://api.devnet.solana.com")

with open("course_wallet.bin", "rb") as f:
    kp_bytes = f.read()

from solders.keypair import Keypair
kp = Keypair.from_bytes(kp_bytes)

sig = client.request_airdrop(kp.pubkey(), 1_000_000_000)  # 1 SOL = 1e9 lamports
print("Airdrop response:", sig)
```

---

## 8. Практическое соглашение курса (рекомендуемая процедура)

1. Каждый ученик создаёт `course_wallet.bin` один раз (Л10).  
2. Файл добавляется в `.gitignore` и хранится у ученика локально (или в зашифрованном хранилище).  
3. После создания — пополняем кошелёк (Урок 13) тестовыми средствами devnet.  
4. Всё последующее в примерах курса будет показывать работу с этим `course_wallet` (подпись, создание аккаунтов, тесты).  

Это уменьшит повторяющиеся airdrop'ы и обеспечит консистентность примеров.

---

## 9. Практические задания

1. Сгенерируйте `course_wallet.bin` и сохраните 64 байта.  
2. Добавьте `course_wallet.bin` в `.gitignore`.  
3. Пополните кошелёк через Урок 13 (airdrop) и проверьте баланс.  
4. Используйте `course_wallet` в следующем уроке (Урок 11) как плательщика.

---

## 10. Ключевые выводы

- Seed в Solana — это бинарный материал (обычно 32 байта), который служит источником приватного ключа.  
- В `solders` и в практических примерах мы храним и восстанавливаем полную пару (`bytes(Keypair)`, 64 байта).  
- Для курса рекомендуем создать один общий `course_wallet` и пополнить его в devnet (Урок 13), чтобы использовать его везде как пример.

---

## Перекрёстные ссылки

- Урок 8 — `solders`: строгие типы и структуры.  
- Урок 11 — Подписи транзакций (будет использовать `course_wallet`).  
- Урок 13 — Airdrop в devnet и проверка баланса через RPC (как пополнить `course_wallet`).  
- Урок 12 — Безопасное хранение ключей (рекомендации для production).

---

## Навигация

[← Урок 9 — Генерация Keypair и форматы ключей](Lesson_9.md)  
[→ Урок 11 — Подписи транзакций: как и почему подписываем](Lesson_11.md)

