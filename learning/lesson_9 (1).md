# Урок 9 — Генерация Keypair и форматы ключей (raw, hex, base58)

---

## 1. Введение

В Solana **Keypair** — это криптографическая пара ключей: **приватный** (секретный) и **публичный**.  
Публичный ключ (`Pubkey`) — это **адрес аккаунта** в сети; приватный — право подписи операций этим аккаунтом.

Каждая транзакция в Solana подписывается по схеме **Ed25519**, которая обеспечивает безопасность, скорость и компактность подписи.  
Этот урок объясняет:
- как формируются ключи Ed25519;
- как их сохранять, загружать и проверять;
- в каких форматах они используются в Solana.

---

## 2. Что такое Ed25519

### 2.1. Основа алгоритма
Ed25519 — это реализация **EdDSA (Edwards-curve Digital Signature Algorithm)**,  
работающая на **эллиптической кривой Curve25519**, определённой над конечным полем `2^255 - 19`.

Эта кривая выбрана из-за:
- высокой скорости вычислений (до 10–20 раз быстрее, чем RSA);
- устойчивости к известным атакам на эллиптические кривые;
- простоты реализации без скрытых параметров (отсутствуют «бэкдоры»);
- короткой длины ключей и подписей (32 и 64 байта соответственно).

### 2.2. Что происходит при генерации
При создании `Keypair`:
1. Генерируется **seed** — 32 случайных байта.  
2. Из него через функцию хэширования SHA-512 получают пару чисел, определяющих приватный и публичный ключ.  
3. Публичный ключ (`Pubkey`) вычисляется как **точка на кривой** Curve25519, умноженная на генератор кривой.  
4. В Solana публичный ключ представлен в **base58** и служит **адресом аккаунта**.

### 2.3. Почему 64 байта, если seed — 32
- Приватный ключ Ed25519 хранит **32 байта seed** и **32 байта публичного ключа**.  
- Эти 64 байта вместе позволяют полностью восстановить пару.  
- Поэтому в Solana (через `solders`) `bytes(Keypair)` всегда возвращает 64 байта.

> Подробнее о криптографической роли подписи и проверке см. Урок 11 — «Подписи транзакций: как и почему подписываем».

---

## 3. Форматы представления ключей

| Формат | Размер | Использование |
|---|---|---|
| **Raw (байты)** | 64 байта | для хранения, сериализации |
| **Hex** | 128 символов (64 байта) | отладка, логи |
| **Base58** | ~44 символа | отображение публичных ключей (адреса Solana) |

Используем код из [`examples/Python/L9-Formats_print.py`](../examples/Python/L9-Formats_print.py):
```python
from solders.keypair import Keypair

kp = Keypair()
pub = kp.pubkey()

print("Адрес (base58):", str(pub))
print("Публичный ключ, байты:", len(bytes(pub)))     # 32
print("Keypair, байты:", len(bytes(kp)))             # 64
print("Keypair, hex:", bytes(kp).hex()[:64], "...")
```

---

## 4. Генерация Keypair (случайная)

Случайная генерация — самый безопасный вариант, используемый в большинстве SDK.

Используем код из [`examples/Python/L9-Keypair_generate.py`](../examples/Python/L9-Keypair_generate.py):
```python
from solders.keypair import Keypair

kp = Keypair()  # криптографически стойкая генерация Ed25519
print("Адрес (pubkey):", kp.pubkey())
print("Длина bytes(kp):", len(bytes(kp)))  # 64
```

> Внутри Solana используется системный источник энтропии. Для детерминированной генерации из seed см. Урок 10.

---

## 5. Структура данных Keypair в `solders`

| Поле | Тип | Размер | Описание |
|---|---|---|---|
| `secret` | bytes | 32 | Секретный seed (вход SHA-512 при генерации) |
| `public` | bytes | 32 | Точка на Curve25519 — адрес аккаунта |
| `serialized` | bytes | 64 | `[secret + public]`, используется при сохранении |

Используем код из [`examples/Python/L9-Keypair_structure.py`](../examples/Python/L9-Keypair_structure.py):
```python
from solders.keypair import Keypair

kp = Keypair()
print("Seed (32 байта):", len(kp.secret()))
print("Pubkey (32 байта):", len(bytes(kp.pubkey())))
print("Сериализованный (64 байта):", len(bytes(kp)))
```

---

## 6. Сохранение и загрузка ключей

### 6.1. JSON (удобно для devnet)
Используем код из [`examples/Python/L9-Keypair_save_load_json.py`](../examples/Python/L9-Keypair_save_load_json.py):
```python
import json
from solders.keypair import Keypair

kp = Keypair()
with open("my_wallet.json", "w") as f:
    json.dump(list(bytes(kp)), f)

with open("my_wallet.json") as f:
    data = bytes(json.load(f))
kp2 = Keypair.from_bytes(data)

print("Совпадает:", kp.pubkey() == kp2.pubkey())
```

### 6.2. Бинарный формат
Используем код из [`examples/Python/L9-Keypair_save_load_bin.py`](../examples/Python/L9-Keypair_save_load_bin.py):
```python
from solders.keypair import Keypair

kp = Keypair()
with open("wallet.bin", "wb") as f:
    f.write(bytes(kp))

with open("wallet.bin", "rb") as f:
    raw = f.read()
kp2 = Keypair.from_bytes(raw)

print("Совпадает:", kp.pubkey() == kp2.pubkey())
```

> Ошибка «expected 64 bytes» (см. Урок 8) возникает, если сохранить только 32 байта (`kp.secret()`).

---

## 7. Проверка и конвертации

Используем код из [`examples/Python/L9-Check_formats.py`](../examples/Python/L9-Check_formats.py):
```python
from solders.keypair import Keypair
from solders.pubkey import Pubkey

kp = Keypair()
pub = kp.pubkey()

print("Адрес (base58):", str(pub))
print("Pubkey hex:", bytes(pub).hex())

# восстановление из строки
restored = Pubkey.from_string(str(pub))
print("Совпадает:", restored == pub)
```

---

## 8. Связь с транзакциями и программами

Ключевая роль `Keypair` в Solana — **предоставление криптографической подписи и прав владения**.  
Он используется в каждом действии, где требуется подтвердить авторство, оплатить комиссию или создать новый аккаунт.

### 8.1. В транзакциях

Каждая транзакция в Solana содержит:
- одно или несколько действий (`Instruction`);
- публичные ключи аккаунтов, участвующих в действиях;
- подписи всех аккаунтов, помеченных `is_signer=True`.

`Keypair` — это источник подписи.  
Плательщик комиссии (payer) **обязан** подписать транзакцию, иначе RPC-узел вернёт ошибку `missing required signature`.

Пример логической цепочки:
1. Собираем `Instruction` (см. Урок 8, раздел 8).  
2. Формируем `Message`, добавляем payer (см. Урок 8, раздел 9.1).  
3. Подписываем `Message` с помощью `Keypair` (см. Урок 8, раздел 9.2).  
4. Получаем `Signature` и отправляем через RPC (см. Урок 11 и 14).  

**Итог:** без `Keypair` невозможно завершить ни одну транзакцию в сети Solana.

---

### 8.2. В системных инструкциях

При работе с **System Program** (см. Урок 8, раздел 10):
- `Keypair` плательщика используется в инструкциях `transfer`, `create_account`, `allocate`, `assign`;
- подпись Keypair подтверждает изменение баланса и создание аккаунта;
- публичный ключ Keypair становится владельцем (`owner`) или адресом нового аккаунта.

Пример:
```python
ix = create_account(CreateAccountParams(
    from_pubkey=payer.pubkey(),
    to_pubkey=new_account.pubkey(),
    lamports=1_000_000,
    space=128,
    owner=program_owner
))
```
Здесь:
- `payer` — `Keypair`, подписывающий и оплачивающий операцию;
- `new_account` — `Keypair`, для которого создаётся новый аккаунт;
- `program_owner` — `Pubkey` программы, которая будет владеть этим аккаунтом.

---

### 8.3. В PDA и пользовательских программах

`Keypair` также участвует в инициализации и управлении **PDA (Program Derived Address)** — см. Урок 27:  
- PDA вычисляется из `seed` и `program_id` и не имеет приватного ключа;  
- однако для его финансирования и первичного создания требуется **подписанный плательщик** (`Keypair`);  
- подпись Keypair гарантирует, что именно владелец SOL инициирует создание PDA и передачу лампортов.

---

### 8.4. В on-chain программах и взаимодействии

В on-chain программах (см. Уроки 29–36):
- при вызове функции программы `Keypair` пользователя предоставляет подпись для аутентификации;  
- внутри программы Solana проверяет, что соответствующий `Pubkey` действительно подписал сообщение (`verify_ed25519`);  
- это обеспечивает безопасность и предотвращает подмену вызовов.

---

### 8.5. В индексаторах, аудитах и логах

Публичная часть `Keypair` используется для:
- привязки транзакций к пользователю (например, логирование по адресу);
- проверки статуса транзакций (`get_signature_statuses`, см. Урок 8, раздел 6);
- аудита активности в индексаторах и аналитических сервисах (см. Уроки 41–44).

---

**Вывод:**  
`Keypair` — это не просто пара байтов, а центральный объект авторизации, владения и доверия в Solana.  
Он связывает всё: транзакции, программы, PDA и хранение данных.  
Без правильного понимания роли `Keypair` нельзя корректно строить ни клиентскую логику, ни on-chain программу.

---

## 9. Безопасность

- Не храните ключи в репозиториях или облаке без шифрования.  
- Для продакшна — используйте аппаратные модули (HSM).  
- Не путайте публичный ключ (адрес) и приватный (seed).  
- Не передавайте приватный ключ через RPC или WebSocket.

---

## 10. Практические задания

1. Сгенерируйте новый Keypair и сохраните в `my_wallet.json`.  
2. Загрузите его и убедитесь, что адрес совпадает.  
3. Переведите его в бинарный формат и обратно.  
4. Преобразуйте публичный ключ в hex и base58, сравните длины.  
5. Подготовьте 32-байтовый seed для следующего урока.

---

## 11. Ключевые выводы

- Алгоритм **Ed25519** обеспечивает безопасные и быстрые подписи для Solana.  
- Один Keypair = 32 байта seed + 32 байта публичного ключа.  
- Публичный ключ (`Pubkey`) — адрес аккаунта в сети.  
- Сохраняйте **все 64 байта** для возможности восстановления.  
- Ключи в Solana полностью совместимы с Rust/TypeScript SDK через одинаковую схему Ed25519.

---

## 12. Перекрёстные ссылки

- Урок 2 — «Основные сущности: аккаунты, программы, транзакции, инструкции».  
- Урок 7 — «Работа с библиотекой `solana` и RPC».  
- Урок 8 — «`solders`: строгие типы и структуры».  
- Урок 10 — «Seed / восстановление и импорт» (генерация из бинарного seed).  
- Урок 11 — «Подписи транзакций: как и почему подписываем».  
- Урок 12 — «Безопасное хранение ключей».  
- Урок 14 — «Перевод SOL: сборка, подпись и подтверждение».  
- Урок 27 — «PDA: концепт и использование».

---

## Навигация

[← Урок 8 — Знакомство с `solders`: строгие типы и структуры Solana](Lesson_8.md)  
[→ Урок 10 — Seed / восстановление и импорт (без мнемоник/BIP-39)](Lesson_10.md)

