# Урок 12 — Безопасное хранение ключей: локальные методы и основы продакшн‑подходов

---

## 1. Введение

Каждая операция в Solana, требующая подписи, зависит от приватного ключа. Потеря или утечка приватного ключа означает потерю всех средств и полного контроля над аккаунтом. Поэтому безопасное хранение ключей — фундаментальный аспект разработки.

В этом уроке мы рассмотрим два уровня:

1. **Локальная безопасная работа** — то, что должен применять каждый разработчик во время обучения и разработки.
2. **Краткий обзор продакшн‑решений** — то, что будет подробно разобрано в Уроке 49 (Vault/KMS/HSM). Здесь только основы.

Связанные уроки:
- Урок 9 — Форматы ключей и структура Keypair
- Урок 10 — Создание `course_wallet.bin`
- Урок 11 — Подписи транзакций
- Урок 49 — Vault/HSM/Secrets managers (подробно про продакшн‑подходы)

---

## 2. Локальный уровень безопасности — базовые правила

Перед тем как говорить о продакшн‑решениях, необходимо освоить локальные меры защиты. Это то, что обязан соблюдать каждый, даже если он просто пишет учебный скрипт.

### 2.1. Никогда не храните приватные ключи в репозитории

Запрещено:
- хранить `course_wallet.bin` или любые приватные ключи в GitHub;
- добавлять ключи в коммиты даже случайно;
- хранить ключи в открытом виде в JSON/ENV.

Обязательно:
- добавить в `.gitignore`:
```
# приватные ключи
*.bin
*.json
*
```

---

### 2.2. Всегда сохраняйте **64 байта** (bytes(Keypair))

См. Урок 9: приватный ключ Solana состоит из 64 байт: `32 байта seed + 32 байта public`.

При восстановлении используйте:
```python
kp = Keypair.from_bytes(raw_64_bytes)
```

Если сохранить только 32 байта (seed), вы потеряете возможность восстановления через `solders`.

См. Урок 10 — правильный способ создания `course_wallet.bin`.

---

### 2.3. Локальное шифрование приватного ключа

Рекомендуется шифровать файл с помощью любого удобного вам инструмента:
- **GPG** (`gpg -c course_wallet.bin`)
- **age** (современный простой инструмент: https://age-encryption.org)
- **OpenSSL AES** (с симметричным ключом)

Пример шифрования через GPG:
```
gpg -c course_wallet.bin
```
Появится файл `course_wallet.bin.gpg`, а исходный можно удалить.

---

### 2.4. Права доступа к файлам

На Unix‑системах:
```
chmod 600 course_wallet.bin
```
Это ограничит доступ только владельцу.

На Windows:
- храните ключи в каталоге пользователя;
- не размещайте их на рабочем столе или в общих папках.

---

### 2.5. Никогда не логируйте приватный ключ

Запрещено:
```python
print(bytes(kp))      # запрещено
print(kp.secret())    # запрещено
```

Разрешено:
```python
print(kp.pubkey())    # безопасно
```

---

## 3. Резервное копирование (обязательно)

1. Храните резервную копию `course_wallet.bin` в защищённом месте.
2. Используйте **минимум два канала хранения**:
   - локальный зашифрованный файл;
   - внешний носитель (USB) с шифрованием;
   - при необходимости облако **только в зашифрованном виде**.
3. Никогда не храните ключи в открытом виде в Telegram, Discord, Email.

---

## 4. Импорт и восстановление ключей (локально)

В курсе мы используем один стандартный способ загрузки учебного кошелька `course_wallet.bin`. Он был введён в Уроке 10 и далее считается базовым.

Используем код из [`examples/Python/L10-Load_course_keypair.py`](../examples/Python/L10-Load_course_keypair.py):
```python
from solders.keypair import Keypair

with open("course_wallet.bin", "rb") as f:
    raw = f.read()

kp = Keypair.from_bytes(raw)
print("Загруженный pubkey:", kp.pubkey())
```
### Пример использования зашифрованного ключа (GPG)
Если вы зашифровали ключ с помощью `gpg -c course_wallet.bin`, то перед загрузкой его в Python необходимо расшифровать файл. Делается это безопасно, без сохранения расшифрованного файла на диск.

Используем код из [`examples/Python/L12-Load_gpg_encrypted_keypair.py`](../examples/Python/L12-Load_gpg_encrypted_keypair.py):
```python
# Пример загрузки зашифрованного ключа без сохранения расшифрованного файла
import subprocess
from solders.keypair import Keypair

# Расшифровываем в stdout (команда запросит пароль GPG)
decrypted = subprocess.check_output(["gpg", "--decrypt", "course_wallet.bin.gpg"])

# Создаём Keypair прямо из полученных байтов
kp = Keypair.from_bytes(decrypted)
print("Загруженный pubkey:", kp.pubkey())
```

Преимущества такого подхода:
- расшифрованные данные **не записываются на диск**;
- приватный ключ доступен только в памяти процесса;
- доступ к ключу защищён паролем GPG.



Во всех следующих уроках этот фрагмент подразумевается как уже знакомый и используется для получения `Keypair` курса из файла.

---

## 5. Защита ключей при запуске скриптов

- Не передавайте приватные ключи через аргументы командной строки.
- Если ключ нужно загружать — используйте файл или защищённые переменные окружения.
- Если работаете с несколькими ключами — разграничивайте уровни доступа.

---

## 6. Обзор продакшн‑подходов (коротко)

Подробно — в **Уроке 49**, здесь даём только общее представление.

### 6.1. Vault‑решения

HashiCorp Vault или аналогичные системы позволяют:
- хранить ключи централизованно;
- ограничивать права на доступ;
- регистрировать все операции.

Использование: бэкенды dApp, сервисы выплат, корпоративные приложения.

---

### 6.2. KMS: AWS/GCP/Azure Key Management Service

Облачные провайдеры позволяют хранить приватные ключи в устройстве, недоступном напрямую.

Преимущества:
- невозможность утечки «сырых» ключей;
- аппаратная защита;
- журналирование операций.

---

### 6.3. HSM (Hardware Security Module)

Аппаратный модуль, который выполняет подпись транзакций, **не раскрывая приватный ключ**. Применяется в банках, крупных биржах, кастодиальных сервисах.

---

### 6.4. Аппаратные кошельки (Ledger, Trezor, ...)

Надёжный вариант для пользователей и разработчиков.

Преимущества:
- приватный ключ никогда не хранится на компьютере;
- подтверждение транзакций — физическое действие.

Более подробно обсудим при работе с NFT (у продавцов/минт‑ботов часто используется аппаратный кошелёк). См. Уроки 56–57.

---

## 7. Практические рекомендации курса

1. Держите `course_wallet.bin` только **локально**, добавьте в `.gitignore`.
2. Зашифруйте файл с помощью GPG/age/openssl.
3. Создайте резервную копию в безопасном месте.
4. Никогда не логируйте байты приватного ключа.
5. Для продакшн‑подходов ориентируйтесь на Урок 49.

---

## 8. Практические задания

1. Зашифруйте свой `course_wallet.bin` любым способом и удалите незашифрованную копию.
2. Создайте резервную копию (USB или облако) в зашифрованном виде.
3. Попробуйте загрузить ключ, дешифруя файл вручную.
4. Составьте свой минимальный "план хранения ключей" для тестовых и продакшн‑сценариев.

---

## 9. Ключевые выводы

- Приватные ключи — главный объект защиты в Solana.
- В учебной практике достаточно соблюдать локальные правила безопасности.
- В продакшне используются Vault/KMS/HSM — это будет подробно в Уроке 49.
- Защита ключей важнее, чем любой код.

---

## Навигация

[← Урок 11 — Подписи транзакций](Lesson_11.md)  
[→ Урок 13 — Airdrop в devnet и проверка баланса](Lesson_13.md)

