# Урок 2 — Основные сущности: аккаунты, программы, транзакции, инструкции

---

## 1. Введение

Чтобы понимать, как взаимодействовать с сетью Solana через код, нужно разобраться в четырёх ключевых сущностях: **аккаунты**, **программы**, **инструкции** и **транзакции**.  
Эти элементы составляют основу всей логики Solana. Всё, что происходит в сети — это обмен инструкциями между аккаунтами и программами.

---

## 2. Аккаунт (Account)

### 2.1. Что такое аккаунт

В Solana **аккаунт** — это универсальный контейнер данных.  
Он может хранить:
- баланс в lamports;
- ссылку на владельца (program_id);
- произвольные данные программы.

Каждый аккаунт имеет публичный ключ (адрес) и может быть создан только через транзакцию.

### 2.2. Структура аккаунта

| Поле | Назначение |
|------|-------------|
| **lamports** | Баланс (в минимальных единицах SOL) |
| **owner** | Публичный ключ программы, управляющей аккаунтом |
| **data** | Массив байтов — данные, которые использует программа |
| **executable** | Флаг, указывающий, является ли аккаунт программой |
| **rent_epoch** | Эпоха, до которой аккаунт освобождён от платы за хранение |

---

### 2.3. Пример: получение информации об аккаунте
Используем код из [`examples/Python/L2-Account_info.py`](../examples/Python/L2-Account_info.py):
```python
from solana.rpc.api import Client
from solders.pubkey import Pubkey


# Подключаемся к тестовой сети (devnet)
client = Client("https://api.devnet.solana.com")

# Указываем адрес аккаунта (публичный ключ)
address = Pubkey.from_string("11111111111111111111111111111111") # пример: системная программа

# Отправляем запрос на получение данных аккаунта
info = client.get_account_info(address)

# Выводим результат в консоль
print(info)
```

#### Описание метода `get_account_info()`

**Назначение:** возвращает всю информацию об аккаунте по его публичному ключу.

**Возвращает:** структуру `Account`, содержащую:
- `lamports` — баланс в минимальных единицах SOL;
- `owner` — ключ программы, которой принадлежит аккаунт;
- `data` — содержимое аккаунта (в кодировке base64 или base58);
- `executable` — `true`, если аккаунт — программа;
- `rent_epoch` — номер эпохи аренды (rent exemption).

#### Параметры

| Параметр | Тип | Обязательный | Описание |
|-----------|-----|---------------|-----------|
| **pubkey** | `Pubkey` | ✅ | Публичный ключ аккаунта, информацию о котором нужно получить. |
| **commitment** | `str` | ❌ | Уровень подтверждения данных (`processed`, `confirmed`, `finalized`). |
| **encoding** | `str` | ❌ | Кодировка данных (`base58` или `base64`, по умолчанию — `base64`). |
| **data_slice** | `dict` | ❌ | Опционально ограничивает объём возвращаемых данных. |


**Реальный вывод (пример):**
```
GetAccountInfoResp {
  context: RpcResponseContext {
    slot: 416131677,
    api_version: Some("3.0.6")
  },
  value: Some(
    Account {
      lamports: 1,
      data: [115, 121, 115, 116, 101, 109, 95, 112, 114, 111, 103, 114, 97, 109],
      owner: Pubkey(NativeLoader1111111111111111111111111111111),
      executable: true,
      rent_epoch: 18446744073709551615
    }
  )
}
```

#### Пояснение к полям результата

| Поле | Значение | Описание |
|------|-----------|----------|
| **context.slot** | `416131677` | Номер слота, в котором получено состояние аккаунта. |
| **context.api_version** | `3.0.6` | Версия RPC API. |
| **lamports** | `1` | Баланс аккаунта в лампортах. |
| **data** | `[115, 121, 115, 116, 101, 109, 95, 112, 114, 111, 103, 114, 97, 109]` | Сырые байты данных аккаунта. Здесь это ASCII-строка `"system_program"`. |
| **owner** | `Pubkey(NativeLoader1111111111111111111111111111111)` | Программа, владеющая аккаунтом. |
| **executable** | `true` | Флаг, показывающий, что аккаунт является программой. |
| **rent_epoch** | `18446744073709551615` | Специальное значение (`u64::MAX`) — аккаунт освобождён от аренды. |

#### Примечание
- Если `executable: true` — это **программа**, а не пользовательский аккаунт.  
- `data` возвращается как **массив байтов**, так как библиотека `solders` работает с бинарным представлением.  
  Для преобразования байтов в строку можно использовать:
  ```python
  print(bytes(info.value.data).decode())
  ```
  → Выведет:
  ```
  system_program
  ```

#### Что важно запомнить
- Все данные в Solana хранятся в аккаунтах.
- Программы не имеют внутреннего состояния — только их аккаунты могут хранить данные.
- Если поле `data` пустое, аккаунт не содержит пользовательской информации.

---

## 3. Программа (Program)

### 3.1. Что такое программа

**Программа (Program)** — это исполняемый код (аналог смарт-контракта), загруженный в блокчейн.  
Она получает инструкции и изменяет состояние аккаунтов, которые ей принадлежат.

В отличие от Ethereum, где контракт хранит своё состояние, в Solana программа не хранит данные — они находятся в **аккаунтах**, которыми программа владеет.

### 3.2. Примеры программ Solana

| Программа | Назначение |
|------------|-------------|
| **System Program** | Создание аккаунтов, перевод SOL |
| **Token Program (SPL)** | Работа с токенами (mint, transfer, burn) |
| **Associated Token Program** | Создание токен-аккаунтов (ATA) |
| **Memo Program** | Добавление заметок (текста) к транзакциям |

---

## 4. Инструкция (Instruction)

### 4.1. Что такое инструкция

**Инструкция (Instruction)** — это единица действия в Solana.  
Она говорит программе:  
> «Вот список аккаунтов, вот что нужно сделать, вот данные для выполнения».

Важно понимать:  
- Инструкция **ничего не выполняет сама по себе**.  
- Это просто **описание операции**, которую потом помещают в **транзакцию**.  
- Только транзакция делает инструкцию «живой».

---

### 4.2. Из чего состоит инструкция

| Поле | Тип | Описание |
|------|-----|----------|
| **program_id** | `Pubkey` | Ключ программы, которая будет выполняться. |
| **accounts** | `list[AccountMeta]` | Список аккаунтов, участвующих в операции. |
| **data** | `bytes` | Сырые бинарные данные — аргументы вызова программы. |

Каждая инструкция говорит:  
> «вызови эту программу (`program_id`), передай ей эти аккаунты (`accounts`), и вот тебе входные данные (`data`)».

---

### 4.3. Пример 1 — простая инструкция без транзакции

Этот код можно запустить **локально**, без сети, чтобы просто увидеть, как инструкция устроена.  
Используем код из [`examples/Python/L2-Instruction.py`](../examples/Python/L2-Instruction.py):
```python
from solders.instruction import Instruction, AccountMeta
from solders.pubkey import Pubkey

# Публичный ключ системной программы (System Program)
program_id = Pubkey.from_string("11111111111111111111111111111111")

# Список аккаунтов (может быть пустым для примера)
accounts: list[AccountMeta] = []

# Создаём инструкцию (используем именованные аргументы)
ix = Instruction(
    program_id=program_id,
    accounts=accounts,
    data=b""  # бинарные данные (пустые)
)

print(ix)
```

**Реальный вывод (пример):**
```
Instruction { program_id: 11111111111111111111111111111111, accounts: [AccountMeta { pubkey: FrhGtLBchMGkkyhLztEDRAbM7x9JgPx4ptAgo2qHmMrE, is_signer: true, is_writable: true }, AccountMeta { pubkey: 11111111111111111111111111111111, is_signer: false, is_writable: true }], data: [2, 0, 0, 0, 232, 3, 0, 0, 0, 0, 0, 0] }
```

---

### 4.4. Пример 2 — инструкция перевода (SPL System Program)

Чтобы показать, как инструкции применяются на практике, можно использовать встроенную функцию `transfer()`.  
Используем код из [`examples/Python/L2-Instruction_transfer.py`](../examples/Python/L2-Instruction_transfer.py):

```python
from solders.keypair import Keypair
from solders.pubkey import Pubkey
from solders.system_program import TransferParams, transfer

# Заглушки — тестовые ключи (не реальные кошельки)
sender = Keypair()
recipient = Pubkey.from_string("11111111111111111111111111111111")

# Создаём инструкцию перевода 1000 лампортов
ix = transfer(
    TransferParams(
        from_pubkey=sender.pubkey(),
        to_pubkey=recipient,
        lamports=1000
    )
)

print(ix)
```

**Реальный вывод (пример):**
```
Instruction { program_id: 11111111111111111111111111111111, accounts: [AccountMeta { pubkey: FrhGtLBchMGkkyhLztEDRAbM7x9JgPx4ptAgo2qHmMrE, is_signer: true, is_writable: true }, AccountMeta { pubkey: 11111111111111111111111111111111, is_signer: false, is_writable: true }], data: [2, 0, 0, 0, 232, 3, 0, 0, 0, 0, 0, 0] }
```

---

### 4.5. Ключевая мысль

Инструкция — это **описание того, что нужно сделать**,  
транзакция — **контейнер, который доставляет инструкции в блокчейн**.  
Можно создавать, анализировать и выводить инструкции **без подключения к сети**, что идеально для обучения и тестирования.

---

## 5. Транзакция (Transaction)

### 5.1. Что такое транзакция

**Транзакция (Transaction)** — это контейнер, в котором собраны одна или несколько инструкций.  
Она определяет последовательность действий и подтверждает права на выполнение этих действий с помощью цифровых подписей.

---

### 5.2. Как формируется транзакция

1. Создаётся инструкция (`Instruction`) — описание действия.
2. Инструкция добавляется в сообщение (`Message`).
3. Транзакция создаётся и подписывается ключами отправителей.
4. Транзакция отправляется на RPC-узел для выполнения.

---

### 5.3. Пример: создание и отправка транзакции
⚠️ Предупреждение:
Этот пример предназначен исключительно для демонстрации структуры транзакции в сети Solana.
Он использует новосозданный кошелёк без баланса, поэтому при выполнении возникнет ошибка:

```
"Transaction simulation failed: Attempt to debit an account but found no record of a prior credit."
```

Чтобы отправить транзакцию успешно, необходимо использовать кошелёк с балансом на devnet или выполнить симуляцию через `simulate_transaction()`(См. п5.7).  
Используем код из [`examples/Python/L2-Instruction_send_transaction.py`](../examples/Python/L2-Instruction_send_transaction.py):

```python
from solders.keypair import Keypair
from solders.pubkey import Pubkey
from solders.system_program import TransferParams, transfer
from solders.transaction import Transaction
from solders.message import Message
from solana.rpc.api import Client

client = Client("https://api.devnet.solana.com")

sender_kp = Keypair()
recipient = Pubkey.from_string("11111111111111111111111111111111")

ix = transfer(
    TransferParams(
        from_pubkey=sender_kp.pubkey(),
        to_pubkey=recipient,
        lamports=1000
    )
)

recent_blockhash = client.get_latest_blockhash().value.blockhash

message = Message.new_with_blockhash(
    [ix],
    sender_kp.pubkey(),
    recent_blockhash
)

# Создаём транзакцию, подписываем и отправляем
tx = Transaction([sender_kp], message, recent_blockhash)
tx.partial_sign([sender_kp], recent_blockhash)
resp = client.send_transaction(tx)

print(resp)
```

---

### 5.4. Пример реального вывода (При успешном запросе)

```
SendTransactionResp {
  result: "3hP6dy5cZyTz7e3fthE4bsX76z4p3PrK4m2Pn4dp9o8bJ5hYbDkPj7ZdbSknEjB6mPqsxX1WbnMExbHd9aSuiTrL",
  context: RpcResponseContext { slot: 416135991 }
}
```

---

### 5.5. Что происходит «под капотом»

| Этап | Что выполняется | Объект |
|------|------------------|--------|
| 1 | Создаётся инструкция `transfer()` | `Instruction` |
| 2 | Инструкция добавляется в сообщение | `Message.new_with_blockhash()` |
| 3 | Транзакция создаётся и подписывается | `Transaction` + `partial_sign()` |
| 4 | RPC-узел проверяет подписи и передаёт транзакцию в сеть | `Client.send_transaction()` |
| 5 | Валидаторы выполняют действия | Solana runtime |

---

### 5.6. Что важно знать

- Одна транзакция может содержать несколько инструкций.  
- Подписи подтверждают права на изменение указанных аккаунтов.  
- Узлы отклоняют транзакции с неверными или неполными подписями.  

---

### 5.7. Проверка транзакции без отправки в сеть

Если у вас нет средств на счёте или вы хотите протестировать код без отправки транзакции, можно использовать **эмуляцию (симуляцию)**.

```python
resp = client.simulate_transaction(tx)
print(simulation)
```
**Реальный вывод (пример):**
```
SimulateTransactionResp { context: RpcResponseContext { slot: 416153409, api_version: Some("3.0.6") }, value: RpcSimulateTransactionResult(RpcSimulateTransactionResult { err: Some(AccountNotFound), logs: Some([]), accounts: None, units_consumed: Some(0), return_data: None, inner_instructions: None, replacement_blockhash: None }) }
```

**Что делает:**  
Эта функция запускает транзакцию в тестовом режиме и проверяет, будет ли она выполнена успешно, не записывая результат в блокчейн.

**Когда использовать:**  
- Нет средств на счёте отправителя.  
- Нужно убедиться, что инструкция корректна.  
- При отладке новых программ.

---

## 6. Как взаимодействуют сущности между собой

| Этап | Действие | Объекты |
|------|-----------|----------|
| 1 | Пользователь формирует действие | dApp, кошелёк |
| 2 | Создаётся инструкция | Instruction |
| 3 | Инструкции объединяются | Transaction |
| 4 | Транзакция подписывается и отправляется | Keypair, RPC |
| 5 | Программа выполняет логику | Program + Accounts |

Таким образом, любая операция в Solana — это взаимодействие **программы** и **аккаунтов** через **инструкции**, упакованные в **транзакции**.

---

## 7. Что важно усвоить

1. В Solana **всё является аккаунтом** — даже программы.
2. Программы не хранят состояние внутри себя — оно хранится в аккаунтах.
3. Каждая операция передаётся как **инструкция** программе.
4. Транзакция может содержать несколько инструкций.
5. Аккаунт не может быть изменён программой, если он не указан в списке участников транзакции.

---

## 8. Вопросы для самопроверки

1. Что такое аккаунт и какие у него ключевые поля?
2. Чем отличается программа от аккаунта?
3. Что делает инструкция и что она содержит?
4. Можно ли объединить несколько инструкций в одну транзакцию?
5. Почему программа не может изменять чужие аккаунты?

---

## 9. Навигация

[← Урок 1 — Что такое Solana и почему она особенная](Lesson_1.md)  
[→ Урок 3 — Ключи и безопасность](Lesson_3.md)



